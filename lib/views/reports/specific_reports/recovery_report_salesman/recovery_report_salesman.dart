import 'dart:typed_data';
import 'dart:io';
import 'package:admin_dashboard_v3/Models/reports/recovey_salesman_report_model.dart';
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:intl/intl.dart';
import 'package:pdf/pdf.dart';
import 'package:printing/printing.dart';
import 'package:pdf/widgets.dart' as pw;
import 'package:path_provider/path_provider.dart';
import 'package:flutter/foundation.dart';

import '../../../../common/widgets/containers/rounded_container.dart';
import '../../../../common/widgets/loaders/tloaders.dart';
import '../../../../common/widgets/shimmers/shimmer.dart';
import '../../../../controllers/shop/shop_controller.dart';
import '../../../../controllers/user/user_controller.dart';

class SalesmanReportPage extends StatelessWidget {
  final List<RecoveryReportModel> salesmanReport;
  final DateTime startDate;
  final DateTime endDate;

  const SalesmanReportPage({
    required this.salesmanReport,
    required this.startDate,
    required this.endDate,
  });

  @override
  Widget build(BuildContext context) {
    final ShopController shopController = Get.find<ShopController>();
    final UserController userController = Get.find<UserController>();

    return Scaffold(
      appBar: AppBar(
        title: const Text('Salesman Report'),
        actions: [
          IconButton(
            icon: const Icon(Icons.download),
            onPressed: () async {
              await savePdf(context);
            },
          ),
        ],
      ),
      body: Center(
        child: TRoundedContainer(
          width: 1000,
          child: salesmanReport.isEmpty
              ? const Text('No data to display')
              : PdfPreview(
            build: (format) => generatePdfInBackground({
              'salesmanReport': salesmanReport,
              'startDate': startDate,
              'endDate': endDate,
              'companyName': shopController.selectedShop?.value.shopname ?? 'No Name',
              'branchName': 'MAIN',
              'generatedBy': userController.currentUser.value.fullName,
              'softwareCompanyName': 'OMGz',
              'format': PdfPageFormat.a4,
            }),
            loadingWidget: const TShimmerEffect(width: 80, height: 80),
            canChangeOrientation: false,
            canChangePageFormat: false,
            canDebug: false,
            initialPageFormat: PdfPageFormat.a4,
            allowPrinting: true,
            allowSharing: true,
            pageFormats: const {
              'A3': PdfPageFormat.a3,
              'A4': PdfPageFormat.a4,
              'A5': PdfPageFormat.a5,
            },
          ),
        ),
      ),
    );
  }

  static Future<Uint8List> generatePdfInBackground(Map<String, dynamic> params) async {
    final List<RecoveryReportModel> salesmanReport = params['salesmanReport'];
    final String companyName = params['companyName'];
    final String branchName = params['branchName'];
    final DateTime startDate = params['startDate'];
    final DateTime endDate = params['endDate'];
    final String generatedBy = params['generatedBy'];
    final String softwareCompanyName = params['softwareCompanyName'];
    final PdfPageFormat format = params['format'];

    final pdf = pw.Document();
    const rowsPerPage = 25;
    final salesmanChunks = _chunkList(salesmanReport, rowsPerPage);

    for (var chunk in salesmanChunks) {
      pdf.addPage(
        pw.MultiPage(
          pageFormat: format,
          build: (context) => [
            pw.Text(companyName, style: pw.TextStyle(fontSize: 16, fontWeight: pw.FontWeight.bold)),
            pw.SizedBox(height: 4),
            pw.Text('Branch: $branchName', style: const pw.TextStyle(fontSize: 12)),
            pw.Text('From: ${startDate.toLocal().toString().split(' ')[0]} To: ${endDate.toLocal().toString().split(' ')[0]}', style: const pw.TextStyle(fontSize: 12)),
            pw.Text("Generated by: $generatedBy", style: const pw.TextStyle(fontSize: 8)),
            pw.Divider(),

            pw.Table(
              border: pw.TableBorder.all(width: 1),
              columnWidths: {
                0: const pw.FlexColumnWidth(1),
                1: const pw.FlexColumnWidth(3),
                2: const pw.FlexColumnWidth(2),
                3: const pw.FlexColumnWidth(2),
                4: const pw.FlexColumnWidth(2),
              },
              children: [
                pw.TableRow(
                  decoration: const pw.BoxDecoration(color: PdfColors.grey300),
                  children: [
                    _tableHeader('Order ID'),
                    _tableHeader('Salesman Name'),
                    _tableHeader('Customer Name'),
                    _tableHeader('Order Date'),
                    _tableHeader('Sale Price'),
                    _tableHeader('Order Type'),
                    _tableHeader('Commission %'),
                    _tableHeader('Commission (Rs)'),
                  ],
                ),
                for (var item in chunk)
                  pw.TableRow(
                    children: [
                      _tableCell(item.orderId.toString()),
                      _tableCell(item.salesmanName),
                      _tableCell(item.customerName),
                      _tableCell(DateFormat('dd/MM/yyyy').format(item.orderDate)),
                      _tableCell('Rs ${item.salePrice.toStringAsFixed(2)}'),
                      _tableCell(item.orderType),
                      _tableCell(item.commissionPercent.toStringAsFixed(2)),
                      _tableCell('Rs ${item.commissionInRs.toStringAsFixed(2)}'),
                    ],
                  ),
              ],
            ),

            pw.SizedBox(height: 16),
            pw.Align(
              alignment: pw.Alignment.bottomCenter,
              child: pw.Column(
                children: [
                  pw.Row(
                    mainAxisAlignment: pw.MainAxisAlignment.spaceBetween,
                    children: [
                      pw.Text(softwareCompanyName, style: pw.TextStyle(fontSize: 10, fontWeight: pw.FontWeight.bold)),
                      pw.BarcodeWidget(
                        data: 'https://www.omgzz.com',
                        barcode: pw.Barcode.qrCode(),
                        width: 50,
                        height: 50,
                      ),
                    ],
                  ),
                ],
              ),
            ),
          ],
        ),
      );
    }

    return pdf.save();
  }

  static List<List<T>> _chunkList<T>(List<T> list, int chunkSize) {
    List<List<T>> chunks = [];
    for (var i = 0; i < list.length; i += chunkSize) {
      chunks.add(list.sublist(i, i + chunkSize > list.length ? list.length : i + chunkSize));
    }
    return chunks;
  }

  Future<void> savePdf(BuildContext context) async {
    final ShopController shopController = Get.find<ShopController>();
    final UserController userController = Get.find<UserController>();
    try {
      final pdfBytes = await compute(
        generatePdfInBackground,
        {
          'salesmanReport': salesmanReport,
          'startDate': startDate,
          'endDate': endDate,
          'companyName': shopController.selectedShop?.value.shopname ?? 'No Name',
          'branchName': 'MAIN',
          'generatedBy': userController.currentUser.value.fullName,
          'softwareCompanyName': 'OMGz',
          'format': PdfPageFormat.a4,
        },
      );

      final downloadsDir = await getDownloadsDirectory();
      if (downloadsDir == null) throw Exception("Downloads directory not found");

      final file = File('${downloadsDir.path}/Salesman_Report_${startDate.toLocal().toString().split(' ')[0]}_${endDate.toLocal().toString().split(' ')[0]}.pdf');
      await file.writeAsBytes(pdfBytes);

      TLoader.successSnackBar(title: "PDF saved successfully!");
    } catch (e) {
      TLoader.errorSnackBar(title: "Failed to save PDF", message: e.toString());
    }
  }

  static pw.Widget _tableHeader(String text) {
    return pw.Padding(
      padding: const pw.EdgeInsets.all(4),
      child: pw.Text(text, style: pw.TextStyle(fontWeight: pw.FontWeight.bold, fontSize: 10)),
    );
  }

  static pw.Widget _tableCell(String text) {
    return pw.Padding(
      padding: const pw.EdgeInsets.all(4),
      child: pw.Text(text, style: const pw.TextStyle(fontSize: 10)),
    );
  }
}

