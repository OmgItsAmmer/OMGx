[
  {
    "function_name": "add_to_cart_validation",
    "parameters": "p_variant_id_input integer, p_new_quantity_input integer",
    "function_body": "CREATE OR REPLACE FUNCTION public.add_to_cart_validation(p_variant_id_input integer, p_new_quantity_input integer)\n RETURNS boolean\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    v_customer_id INT;\r\n    v_current_stock INT := 0;\r\n    v_customer_current_quantity INT := 0;\r\nBEGIN\r\n    -- Get customer ID from logged-in user\r\n    SELECT customer_id INTO v_customer_id\r\n    FROM customers\r\n    WHERE auth_uid = auth.uid();\r\n\r\n    IF v_customer_id IS NULL THEN\r\n        RETURN FALSE;\r\n    END IF;\r\n\r\n    -- Get stock\r\n    SELECT COALESCE(stock, 0) INTO v_current_stock\r\n    FROM product_variants\r\n    WHERE variant_id = p_variant_id_input;\r\n\r\n    IF v_current_stock <= 0 THEN\r\n        RETURN FALSE;\r\n    END IF;\r\n\r\n    -- Get total quantity user already added\r\n    SELECT COALESCE(SUM(\r\n        CASE \r\n            WHEN quantity ~ '^[0-9]+$' THEN quantity::INT \r\n            ELSE 0 \r\n        END\r\n    ), 0) INTO v_customer_current_quantity\r\n    FROM cart\r\n    WHERE variant_id = p_variant_id_input\r\n      AND customer_id = v_customer_id;\r\n\r\n    -- Validate: not exceeding stock\r\n    IF (v_customer_current_quantity + p_new_quantity_input) <= v_current_stock THEN\r\n        RETURN TRUE;\r\n    ELSE\r\n        RETURN FALSE;\r\n    END IF;\r\nEXCEPTION\r\n    WHEN OTHERS THEN\r\n        RETURN FALSE;\r\nEND;\r\n$function$\n"
  },
  {
    "function_name": "apply_admin_stock_changes",
    "parameters": "p_variant_changes jsonb",
    "function_body": "CREATE OR REPLACE FUNCTION public.apply_admin_stock_changes(p_variant_changes jsonb)\n RETURNS boolean\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    variant_entry RECORD;\r\nBEGIN\r\n    -- Apply variant stock changes (since every product must have variants)\r\n    FOR variant_entry IN \r\n        SELECT key::INTEGER as variant_id, value::INTEGER as quantity_change\r\n        FROM jsonb_each_text(p_variant_changes)\r\n        WHERE value::INTEGER != 0\r\n    LOOP\r\n        -- For variants reducing stock, use the existing function\r\n        IF variant_entry.quantity_change < 0 THEN\r\n            PERFORM reduce_variant_stock(\r\n                variant_entry.variant_id, \r\n                ABS(variant_entry.quantity_change)\r\n            );\r\n        ELSE\r\n            -- For increasing stock, update directly\r\n            UPDATE product_variants \r\n            SET stock = stock + variant_entry.quantity_change,\r\n                updated_at = NOW()\r\n            WHERE variant_id = variant_entry.variant_id;\r\n        END IF;\r\n    END LOOP;\r\n    \r\n    RETURN TRUE;\r\nEXCEPTION\r\n    WHEN OTHERS THEN\r\n        RAISE;\r\nEND;\r\n$function$\n"
  },
  {
    "function_name": "apply_admin_stock_changes",
    "parameters": "p_product_changes jsonb, p_variant_changes jsonb",
    "function_body": "CREATE OR REPLACE FUNCTION public.apply_admin_stock_changes(p_product_changes jsonb, p_variant_changes jsonb)\n RETURNS boolean\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    product_entry RECORD;\r\n    variant_entry RECORD;\r\n    v_current_stock INTEGER;\r\nBEGIN\r\n    -- Apply product stock changes\r\n    FOR product_entry IN \r\n        SELECT key::INTEGER as product_id, value::INTEGER as quantity_change\r\n        FROM jsonb_each_text(p_product_changes)\r\n        WHERE value::INTEGER != 0\r\n    LOOP\r\n        -- Lock the row and get current stock\r\n        SELECT stock_quantity INTO v_current_stock\r\n        FROM products\r\n        WHERE product_id = product_entry.product_id\r\n        FOR UPDATE;\r\n        \r\n        -- Check if we have enough stock (only when reducing stock)\r\n        IF product_entry.quantity_change < 0 AND \r\n           v_current_stock < ABS(product_entry.quantity_change) THEN\r\n            RAISE EXCEPTION 'Insufficient product stock. Product ID: %, Available: %, Requested: %', \r\n                product_entry.product_id, v_current_stock, ABS(product_entry.quantity_change);\r\n        END IF;\r\n        \r\n        -- Apply the change\r\n        UPDATE products \r\n        SET stock_quantity = stock_quantity + product_entry.quantity_change,\r\n            updated_at = NOW()\r\n        WHERE product_id = product_entry.product_id;\r\n    END LOOP;\r\n    \r\n    -- Apply variant stock changes\r\n    FOR variant_entry IN \r\n        SELECT key::INTEGER as variant_id, value::INTEGER as quantity_change\r\n        FROM jsonb_each_text(p_variant_changes)\r\n        WHERE value::INTEGER != 0\r\n    LOOP\r\n        -- For variants reducing stock, use the existing function\r\n        IF variant_entry.quantity_change < 0 THEN\r\n            PERFORM reduce_variant_stock(\r\n                variant_entry.variant_id, \r\n                ABS(variant_entry.quantity_change)\r\n            );\r\n        ELSE\r\n            -- For increasing stock, update directly\r\n            UPDATE product_variants \r\n            SET stock = stock + variant_entry.quantity_change,\r\n                updated_at = NOW()\r\n            WHERE variant_id = variant_entry.variant_id;\r\n        END IF;\r\n    END LOOP;\r\n    \r\n    RETURN TRUE;\r\nEXCEPTION\r\n    WHEN OTHERS THEN\r\n        RAISE;\r\nEND;\r\n$function$\n"
  },
  {
    "function_name": "bytea_to_text",
    "parameters": "data bytea",
    "function_body": "CREATE OR REPLACE FUNCTION public.bytea_to_text(data bytea)\n RETURNS text\n LANGUAGE c\n IMMUTABLE STRICT\nAS '$libdir/http', $function$bytea_to_text$function$\n"
  },
  {
    "function_name": "calculate_admin_order_totals",
    "parameters": "p_cart_items jsonb, p_salesman_comission integer DEFAULT 0, p_discount_percent numeric DEFAULT 0, p_payment_method text DEFAULT 'cash'::text",
    "function_body": "CREATE OR REPLACE FUNCTION public.calculate_admin_order_totals(p_cart_items jsonb, p_salesman_comission integer DEFAULT 0, p_discount_percent numeric DEFAULT 0, p_payment_method text DEFAULT 'cash'::text)\n RETURNS TABLE(subtotal numeric, tax numeric, shipping numeric, salesman_comission integer, discount numeric, total numeric, buying_price_total numeric)\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    item JSONB;\r\n    v_subtotal NUMERIC := 0;\r\n    v_buying_price_total NUMERIC := 0;\r\n    v_tax NUMERIC := 0;\r\n    v_shipping NUMERIC := 0;\r\n    v_salesman_comission INTEGER := 0;\r\n    v_discount NUMERIC := 0;\r\n    v_total NUMERIC := 0;\r\n    shop_settings RECORD;\r\nBEGIN\r\n    -- Calculate subtotal and buying price total\r\n    FOR item IN SELECT * FROM jsonb_array_elements(p_cart_items)\r\n    LOOP\r\n        v_subtotal := v_subtotal + ((item->>'sellPrice')::NUMERIC * (item->>'quantity')::NUMERIC);\r\n        \r\n        -- Calculate buying price (all products have variants, so multiply by quantity)\r\n        v_buying_price_total := v_buying_price_total + \r\n            ((item->>'buyPrice')::NUMERIC * (item->>'quantity')::NUMERIC);\r\n    END LOOP;\r\n    \r\n    -- Get shop settings\r\n    SELECT taxrate, shipping_price INTO shop_settings\r\n    FROM shop\r\n    LIMIT 1;\r\n    \r\n    v_tax := COALESCE(shop_settings.taxrate, 0);\r\n    \r\n    -- For POS orders, shipping is always 0 (customer pickup)\r\n    v_shipping := 0;\r\n    \r\n    -- Calculate salesman commission\r\n    v_salesman_comission := ROUND((v_subtotal * p_salesman_comission) / 100);\r\n    \r\n    -- Calculate discount\r\n    v_discount := (v_subtotal * p_discount_percent) / 100;\r\n    \r\n    -- Apply discount to subtotal\r\n    v_subtotal := v_subtotal - v_discount;\r\n    \r\n    -- Calculate total\r\n    v_total := v_subtotal + v_tax + v_shipping + v_salesman_comission;\r\n    \r\n    RETURN QUERY SELECT v_subtotal, v_tax, v_shipping, v_salesman_comission, \r\n                        v_discount, v_total, v_buying_price_total;\r\nEND;\r\n$function$\n"
  },
  {
    "function_name": "calculate_admin_order_totals",
    "parameters": "p_cart_items jsonb, p_salesman_comission numeric DEFAULT 0, p_discount_percent numeric DEFAULT 0, p_payment_method text DEFAULT 'cash'::text",
    "function_body": "CREATE OR REPLACE FUNCTION public.calculate_admin_order_totals(p_cart_items jsonb, p_salesman_comission numeric DEFAULT 0, p_discount_percent numeric DEFAULT 0, p_payment_method text DEFAULT 'cash'::text)\n RETURNS TABLE(subtotal numeric, tax numeric, shipping numeric, salesman_comission numeric, discount numeric, total numeric, buying_price_total numeric)\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    item JSONB;\r\n    v_subtotal NUMERIC := 0;\r\n    v_buying_price_total NUMERIC := 0;\r\n    v_tax NUMERIC := 0;\r\n    v_shipping NUMERIC := 0;\r\n    v_salesman_comission NUMERIC := 0;\r\n    v_discount NUMERIC := 0;\r\n    v_total NUMERIC := 0;\r\n    shop_settings RECORD;\r\nBEGIN\r\n    -- Calculate subtotal and buying price total\r\n    FOR item IN SELECT * FROM jsonb_array_elements(p_cart_items)\r\n    LOOP\r\n        v_subtotal := v_subtotal + ((item->>'sellPrice')::NUMERIC * (item->>'quantity')::NUMERIC);\r\n        \r\n        -- Calculate buying price (all products have variants, so multiply by quantity)\r\n        v_buying_price_total := v_buying_price_total + \r\n            ((item->>'buyPrice')::NUMERIC * (item->>'quantity')::NUMERIC);\r\n    END LOOP;\r\n    \r\n    -- Get shop settings\r\n    SELECT taxrate, shipping_price INTO shop_settings\r\n    FROM shop\r\n    LIMIT 1;\r\n    \r\n    v_tax := COALESCE(shop_settings.taxrate, 0);\r\n    \r\n    -- For POS orders, shipping is always 0 (customer pickup)\r\n    v_shipping := 0;\r\n    \r\n    -- Calculate salesman commission\r\n    v_salesman_comission := (v_subtotal * p_salesman_comission) / 100;\r\n    \r\n    -- Calculate discount\r\n    v_discount := (v_subtotal * p_discount_percent) / 100;\r\n    \r\n    -- Apply discount to subtotal\r\n    v_subtotal := v_subtotal - v_discount;\r\n    \r\n    -- Calculate total\r\n    v_total := v_subtotal + v_tax + v_shipping + v_salesman_comission;\r\n    \r\n    RETURN QUERY SELECT v_subtotal, v_tax, v_shipping, v_salesman_comission, \r\n                        v_discount, v_total, v_buying_price_total;\r\nEND;\r\n$function$\n"
  },
  {
    "function_name": "cleanup_expired_reservations",
    "parameters": "",
    "function_body": "CREATE OR REPLACE FUNCTION public.cleanup_expired_reservations()\n RETURNS integer\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    deleted_count INTEGER;\r\nBEGIN\r\n    DELETE FROM inventory_reservations\r\n    WHERE expires_at < NOW();\r\n    \r\n    GET DIAGNOSTICS deleted_count = ROW_COUNT;\r\n    \r\n    -- Log the cleanup activity\r\n    INSERT INTO security_audit_log (event_type, event_data, severity)\r\n    VALUES ('reservation_cleanup', \r\n            jsonb_build_object('deleted_count', deleted_count), \r\n            'info');\r\n    \r\n    RETURN deleted_count;\r\nEND;\r\n$function$\n"
  },
  {
    "function_name": "confirm_inventory_reservation",
    "parameters": "p_reservation_id character varying",
    "function_body": "CREATE OR REPLACE FUNCTION public.confirm_inventory_reservation(p_reservation_id character varying)\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n    reservation_record RECORD;\r\n    success BOOLEAN := TRUE;\r\nBEGIN\r\n    -- Process each reservation\r\n    FOR reservation_record IN \r\n        SELECT variant_id, quantity \r\n        FROM inventory_reservations \r\n        WHERE reservation_id = p_reservation_id\r\n    LOOP\r\n        -- Use existing reduce_variant_stock function\r\n        BEGIN\r\n            PERFORM reduce_variant_stock(reservation_record.variant_id, reservation_record.quantity);\r\n        EXCEPTION WHEN OTHERS THEN\r\n            success := FALSE;\r\n            EXIT; -- Exit loop on first failure\r\n        END;\r\n    END LOOP;\r\n    \r\n    -- If successful, remove all reservations\r\n    IF success THEN\r\n        DELETE FROM inventory_reservations \r\n        WHERE reservation_id = p_reservation_id;\r\n    END IF;\r\n    \r\n    RETURN success;\r\nEND;\r\n$function$\n"
  },
  {
    "function_name": "copy_address_to_order_address",
    "parameters": "p_address_id integer",
    "function_body": "CREATE OR REPLACE FUNCTION public.copy_address_to_order_address(p_address_id integer)\n RETURNS boolean\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    v_success BOOLEAN := FALSE;\r\nBEGIN\r\n    INSERT INTO public.order_addresses (\r\n        shipping_address,\r\n        phone_number,\r\n        postal_code,\r\n        city,\r\n        country,\r\n        full_name,\r\n        customer_id,\r\n        vendor_id,\r\n        salesman_id,\r\n        user_id,\r\n        address_id\r\n    )\r\n    SELECT\r\n        shipping_address,\r\n        phone_number,\r\n        postal_code,\r\n        city,\r\n        country,\r\n        full_name,\r\n        customer_id,\r\n        vendor_id,\r\n        salesman_id,\r\n        user_id,\r\n        address_id\r\n    FROM\r\n        public.addresses\r\n    WHERE\r\n        address_id = p_address_id;\r\n\r\n    IF FOUND THEN\r\n        v_success := TRUE;\r\n    END IF;\r\n\r\n    RETURN v_success;\r\nEND;\r\n$function$\n"
  },
  {
    "function_name": "copy_address_to_order_addresses",
    "parameters": "p_address_id integer",
    "function_body": "CREATE OR REPLACE FUNCTION public.copy_address_to_order_addresses(p_address_id integer)\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n    address_record RECORD;\r\nBEGIN\r\n    -- Get address details from existing addresses table\r\n    SELECT a.*\r\n    INTO address_record\r\n    FROM addresses a\r\n    WHERE a.address_id = p_address_id;\r\n    \r\n    IF NOT FOUND THEN\r\n        RETURN FALSE;\r\n    END IF;\r\n    \r\n    -- Insert into order_addresses using existing structure\r\n    INSERT INTO order_addresses (\r\n        customer_id,\r\n        full_name,\r\n        phone_number,\r\n        shipping_address,  -- Using existing column name\r\n        city,\r\n        country,\r\n        postal_code,\r\n        vendor_id,\r\n        salesman_id,\r\n        user_id,\r\n        address_id\r\n    ) VALUES (\r\n        address_record.customer_id,  -- Use customer_id from address record\r\n        address_record.full_name,\r\n        address_record.phone_number,\r\n        address_record.shipping_address,\r\n        address_record.city,\r\n        address_record.country,\r\n        address_record.postal_code,\r\n        address_record.vendor_id,\r\n        address_record.salesman_id,\r\n        address_record.user_id,\r\n        address_record.address_id\r\n    );\r\n    \r\n    RETURN TRUE;\r\nEND;\r\n$function$\n"
  },
  {
    "function_name": "get_available_stock",
    "parameters": "variant_id_param integer",
    "function_body": "CREATE OR REPLACE FUNCTION public.get_available_stock(variant_id_param integer)\n RETURNS bigint\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n    total_stock BIGINT;\r\n    reserved_stock BIGINT;\r\nBEGIN\r\n    SELECT stock INTO total_stock \r\n    FROM product_variants \r\n    WHERE variant_id = variant_id_param;\r\n\r\n    RAISE NOTICE 'Total stock: %', total_stock;\r\n\r\n    IF total_stock IS NULL THEN\r\n        RETURN 0;\r\n    END IF;\r\n\r\n    SELECT COALESCE(SUM(quantity), 0) INTO reserved_stock\r\n    FROM inventory_reservations \r\n    WHERE variant_id = variant_id_param \r\n    AND expires_at > NOW();\r\n\r\n    RAISE NOTICE 'Reserved stock: %', reserved_stock;\r\n\r\n    RETURN GREATEST(0, total_stock - reserved_stock);\r\nEND;\r\n$function$\n"
  },
  {
    "function_name": "get_available_stock_for_admin",
    "parameters": "p_variant_id integer",
    "function_body": "CREATE OR REPLACE FUNCTION public.get_available_stock_for_admin(p_variant_id integer)\n RETURNS integer\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    v_total_stock INTEGER;\r\n    v_reserved_stock INTEGER := 0;\r\nBEGIN\r\n    -- Clean up expired reservations first\r\n    DELETE FROM inventory_reservations WHERE expires_at < NOW();\r\n    \r\n    -- Get variant stock (since every product must have variants)\r\n    SELECT stock INTO v_total_stock\r\n    FROM product_variants\r\n    WHERE variant_id = p_variant_id AND is_visible = true;\r\n    \r\n    -- Get reserved stock for this variant\r\n    SELECT COALESCE(SUM(quantity), 0) INTO v_reserved_stock\r\n    FROM inventory_reservations\r\n    WHERE variant_id = p_variant_id AND expires_at > NOW();\r\n    \r\n    RETURN GREATEST(0, COALESCE(v_total_stock, 0) - v_reserved_stock);\r\nEND;\r\n$function$\n"
  },
  {
    "function_name": "get_available_stock_for_admin",
    "parameters": "p_product_id integer, p_variant_id integer DEFAULT NULL::integer",
    "function_body": "CREATE OR REPLACE FUNCTION public.get_available_stock_for_admin(p_product_id integer, p_variant_id integer DEFAULT NULL::integer)\n RETURNS integer\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    v_total_stock INTEGER;\r\n    v_reserved_stock INTEGER := 0;\r\nBEGIN\r\n    -- Clean up expired reservations first\r\n    DELETE FROM inventory_reservations WHERE expires_at < NOW();\r\n    \r\n    IF p_variant_id IS NOT NULL THEN\r\n        -- Get variant stock\r\n        SELECT stock INTO v_total_stock\r\n        FROM product_variants\r\n        WHERE variant_id = p_variant_id AND is_visible = true;\r\n        \r\n        -- Get reserved stock for this variant\r\n        SELECT COALESCE(SUM(quantity), 0) INTO v_reserved_stock\r\n        FROM inventory_reservations\r\n        WHERE variant_id = p_variant_id AND expires_at > NOW();\r\n    ELSE\r\n        -- Get product stock\r\n        SELECT stock_quantity INTO v_total_stock\r\n        FROM products\r\n        WHERE product_id = p_product_id;\r\n        \r\n        -- Get reserved stock for this product (non-variant reservations)\r\n        SELECT COALESCE(SUM(quantity), 0) INTO v_reserved_stock\r\n        FROM inventory_reservations\r\n        WHERE product_id = p_product_id AND variant_id IS NULL AND expires_at > NOW();\r\n    END IF;\r\n    \r\n    RETURN GREATEST(0, COALESCE(v_total_stock, 0) - v_reserved_stock);\r\nEND;\r\n$function$\n"
  },
  {
    "function_name": "handle_order_ready",
    "parameters": "",
    "function_body": "CREATE OR REPLACE FUNCTION public.handle_order_ready()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n  service_url TEXT := 'https://your-endpoint.com/your-path';  -- Replace with actual target URL\r\n  service_key TEXT := 'Bearer YOUR_SERVICE_KEY_HERE';         -- Replace with your actual auth key if needed\r\nBEGIN\r\n  IF NEW.status = 'ready' THEN\r\n    PERFORM http_post(\r\n      service_url,\r\n      json_build_object(\r\n        'order_id', NEW.order_id,\r\n        'customer_id', NEW.customer_id\r\n      )::TEXT,\r\n      ARRAY[\r\n        http_header('Content-Type', 'application/json'),\r\n        http_header('Authorization', service_key)\r\n      ]\r\n    );\r\n  END IF;\r\n  RETURN NEW;\r\nEND;\r\n$function$\n"
  },
  {
    "function_name": "http",
    "parameters": "request http_request",
    "function_body": "CREATE OR REPLACE FUNCTION public.http(request http_request)\n RETURNS http_response\n LANGUAGE c\nAS '$libdir/http', $function$http_request$function$\n"
  },
  {
    "function_name": "http_delete",
    "parameters": "uri character varying",
    "function_body": "CREATE OR REPLACE FUNCTION public.http_delete(uri character varying)\n RETURNS http_response\n LANGUAGE sql\nAS $function$ SELECT public.http(('DELETE', $1, NULL, NULL, NULL)::public.http_request) $function$\n"
  },
  {
    "function_name": "http_delete",
    "parameters": "uri character varying, content character varying, content_type character varying",
    "function_body": "CREATE OR REPLACE FUNCTION public.http_delete(uri character varying, content character varying, content_type character varying)\n RETURNS http_response\n LANGUAGE sql\nAS $function$ SELECT public.http(('DELETE', $1, NULL, $3, $2)::public.http_request) $function$\n"
  },
  {
    "function_name": "http_get",
    "parameters": "uri character varying",
    "function_body": "CREATE OR REPLACE FUNCTION public.http_get(uri character varying)\n RETURNS http_response\n LANGUAGE sql\nAS $function$ SELECT public.http(('GET', $1, NULL, NULL, NULL)::public.http_request) $function$\n"
  },
  {
    "function_name": "http_get",
    "parameters": "uri character varying, data jsonb",
    "function_body": "CREATE OR REPLACE FUNCTION public.http_get(uri character varying, data jsonb)\n RETURNS http_response\n LANGUAGE sql\nAS $function$\n        SELECT public.http(('GET', $1 || '?' || public.urlencode($2), NULL, NULL, NULL)::public.http_request)\n    $function$\n"
  },
  {
    "function_name": "http_head",
    "parameters": "uri character varying",
    "function_body": "CREATE OR REPLACE FUNCTION public.http_head(uri character varying)\n RETURNS http_response\n LANGUAGE sql\nAS $function$ SELECT public.http(('HEAD', $1, NULL, NULL, NULL)::public.http_request) $function$\n"
  },
  {
    "function_name": "http_header",
    "parameters": "field character varying, value character varying",
    "function_body": "CREATE OR REPLACE FUNCTION public.http_header(field character varying, value character varying)\n RETURNS http_header\n LANGUAGE sql\nAS $function$ SELECT $1, $2 $function$\n"
  },
  {
    "function_name": "http_list_curlopt",
    "parameters": "",
    "function_body": "CREATE OR REPLACE FUNCTION public.http_list_curlopt()\n RETURNS TABLE(curlopt text, value text)\n LANGUAGE c\nAS '$libdir/http', $function$http_list_curlopt$function$\n"
  },
  {
    "function_name": "http_patch",
    "parameters": "uri character varying, content character varying, content_type character varying",
    "function_body": "CREATE OR REPLACE FUNCTION public.http_patch(uri character varying, content character varying, content_type character varying)\n RETURNS http_response\n LANGUAGE sql\nAS $function$ SELECT public.http(('PATCH', $1, NULL, $3, $2)::public.http_request) $function$\n"
  },
  {
    "function_name": "http_post",
    "parameters": "uri character varying, data jsonb",
    "function_body": "CREATE OR REPLACE FUNCTION public.http_post(uri character varying, data jsonb)\n RETURNS http_response\n LANGUAGE sql\nAS $function$\n        SELECT public.http(('POST', $1, NULL, 'application/x-www-form-urlencoded', public.urlencode($2))::public.http_request)\n    $function$\n"
  },
  {
    "function_name": "http_post",
    "parameters": "uri character varying, content character varying, content_type character varying",
    "function_body": "CREATE OR REPLACE FUNCTION public.http_post(uri character varying, content character varying, content_type character varying)\n RETURNS http_response\n LANGUAGE sql\nAS $function$ SELECT public.http(('POST', $1, NULL, $3, $2)::public.http_request) $function$\n"
  },
  {
    "function_name": "http_put",
    "parameters": "uri character varying, content character varying, content_type character varying",
    "function_body": "CREATE OR REPLACE FUNCTION public.http_put(uri character varying, content character varying, content_type character varying)\n RETURNS http_response\n LANGUAGE sql\nAS $function$ SELECT public.http(('PUT', $1, NULL, $3, $2)::public.http_request) $function$\n"
  },
  {
    "function_name": "http_reset_curlopt",
    "parameters": "",
    "function_body": "CREATE OR REPLACE FUNCTION public.http_reset_curlopt()\n RETURNS boolean\n LANGUAGE c\nAS '$libdir/http', $function$http_reset_curlopt$function$\n"
  },
  {
    "function_name": "http_set_curlopt",
    "parameters": "curlopt character varying, value character varying",
    "function_body": "CREATE OR REPLACE FUNCTION public.http_set_curlopt(curlopt character varying, value character varying)\n RETURNS boolean\n LANGUAGE c\nAS '$libdir/http', $function$http_set_curlopt$function$\n"
  },
  {
    "function_name": "insert_order_with_items",
    "parameters": "p_order_date timestamp with time zone, p_sub_total numeric, p_status text, p_address_id integer, p_paid_amount numeric, p_customer_id integer, p_user_id integer, p_order_items jsonb[]",
    "function_body": "CREATE OR REPLACE FUNCTION public.insert_order_with_items(p_order_date timestamp with time zone, p_sub_total numeric, p_status text, p_address_id integer, p_paid_amount numeric, p_customer_id integer, p_user_id integer, p_order_items jsonb[])\n RETURNS integer\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n  v_order_id INTEGER;\n  v_item JSONB;\nBEGIN\n  -- Insert the order\n  INSERT INTO public.orders (\n    order_date,\n    total_price,\n    status,\n    address_id,\n    paid_amount,\n    customer_id,\n    user_id\n  ) VALUES (\n    COALESCE(p_order_date, NOW()),\n    p_sub_total,\n    p_status,\n    p_address_id,\n    p_paid_amount,\n    p_customer_id,\n    p_user_id\n  ) RETURNING order_id INTO v_order_id;\n\n  -- Insert order items\n  FOREACH v_item IN ARRAY p_order_items\n  LOOP\n    INSERT INTO public.order_items (\n      order_id,\n      product_id,\n      quantity,\n      price,\n      unit,\n      total_buy_price,\n      variant_id\n    ) VALUES (\n      v_order_id,\n      (v_item->>'product_id')::INTEGER,\n      (v_item->>'quantity')::INTEGER,\n      (v_item->>'price')::NUMERIC(10, 2),\n      v_item->>'unit',\n      (v_item->>'total_buy_price')::NUMERIC(10, 2),\n      (v_item->>'variant_id')::INTEGER\n    );\n  END LOOP;\n\n  RETURN v_order_id;\nEND;\n$function$\n"
  },
  {
    "function_name": "log_price_changes",
    "parameters": "",
    "function_body": "CREATE OR REPLACE FUNCTION public.log_price_changes()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n    -- Log price changes in product_variants\r\n    IF OLD.sell_price IS DISTINCT FROM NEW.sell_price THEN\r\n        INSERT INTO security_audit_log (event_type, event_data, severity)\r\n        VALUES ('price_change',\r\n                jsonb_build_object(\r\n                    'variant_id', NEW.variant_id,\r\n                    'old_price', OLD.sell_price,\r\n                    'new_price', NEW.sell_price,\r\n                    'change_amount', NEW.sell_price - OLD.sell_price\r\n                ),\r\n                'warning');\r\n    END IF;\r\n    \r\n    RETURN NEW;\r\nEND;\r\n$function$\n"
  },
  {
    "function_name": "notify_order_ready",
    "parameters": "",
    "function_body": "CREATE OR REPLACE FUNCTION public.notify_order_ready()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nbegin\r\n  IF NEW.status = 'ready' AND OLD.status IS DISTINCT FROM NEW.status THEN\r\n    RAISE NOTICE 'âœ… Trigger fired: order_id = %, status = %', NEW.order_id, NEW.status;\r\n    \r\n    -- Edge function call (commented to isolate problem)\r\n    -- PERFORM http_post(\r\n    --   url := 'https://jjxqwtltkepeajwtcish.functions.supabase.co/notify-ready',\r\n    --   headers := json_build_object('Content-Type', 'application/json'),\r\n    --   body := json_build_object('new', row_to_json(NEW))\r\n    -- );\r\n\r\n  END IF;\r\n  RETURN NEW;\r\nEND;\r\n$function$\n"
  },
  {
    "function_name": "reduce_variant_stock",
    "parameters": "variant_id_param integer, quantity_param integer",
    "function_body": "CREATE OR REPLACE FUNCTION public.reduce_variant_stock(variant_id_param integer, quantity_param integer)\n RETURNS boolean\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    current_stock INTEGER;\r\nBEGIN\r\n    -- Lock the row for update to prevent race conditions\r\n    SELECT stock INTO current_stock \r\n    FROM product_variants \r\n    WHERE variant_id = variant_id_param \r\n    FOR UPDATE;\r\n    \r\n    -- Check if sufficient stock is available\r\n    IF current_stock IS NULL THEN\r\n        RAISE EXCEPTION 'Product variant not found: %', variant_id_param;\r\n    END IF;\r\n    \r\n    IF current_stock < quantity_param THEN\r\n        RAISE EXCEPTION 'Insufficient stock. Available: %, Requested: %', current_stock, quantity_param;\r\n    END IF;\r\n    \r\n    -- Reduce the stock\r\n    UPDATE product_variants \r\n    SET stock = stock - quantity_param,\r\n        updated_at = NOW()\r\n    WHERE variant_id = variant_id_param;\r\n    \r\n    RETURN TRUE;\r\nEXCEPTION\r\n    WHEN OTHERS THEN\r\n        -- Log the error and re-raise\r\n        RAISE;\r\nEND;\r\n$function$\n"
  },
  {
    "function_name": "reserve_admin_inventory",
    "parameters": "p_reservation_id text, p_cart_items jsonb, p_expiry_minutes integer DEFAULT 10",
    "function_body": "CREATE OR REPLACE FUNCTION public.reserve_admin_inventory(p_reservation_id text, p_cart_items jsonb, p_expiry_minutes integer DEFAULT 10)\n RETURNS boolean\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    item JSONB;\r\n    v_expiry_time TIMESTAMP;\r\nBEGIN\r\n    v_expiry_time := NOW() + INTERVAL '1 minute' * p_expiry_minutes;\r\n    \r\n    -- Clean up any expired reservations first\r\n    DELETE FROM inventory_reservations \r\n    WHERE expires_at < NOW();\r\n    \r\n    -- Reserve each item in the cart (only variant_id since every product must have variants)\r\n    FOR item IN SELECT * FROM jsonb_array_elements(p_cart_items)\r\n    LOOP\r\n        INSERT INTO inventory_reservations (\r\n            reservation_id,\r\n            variant_id,\r\n            quantity,\r\n            expires_at\r\n        ) VALUES (\r\n            p_reservation_id,\r\n            (item->>'variantId')::INTEGER,\r\n            (item->>'quantity')::INTEGER,\r\n            v_expiry_time\r\n        );\r\n    END LOOP;\r\n    \r\n    RETURN TRUE;\r\nEXCEPTION\r\n    WHEN OTHERS THEN\r\n        -- Clean up any partial reservations\r\n        DELETE FROM inventory_reservations \r\n        WHERE reservation_id = p_reservation_id;\r\n        RAISE;\r\nEND;\r\n$function$\n"
  },
  {
    "function_name": "text_to_bytea",
    "parameters": "data text",
    "function_body": "CREATE OR REPLACE FUNCTION public.text_to_bytea(data text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE STRICT\nAS '$libdir/http', $function$text_to_bytea$function$\n"
  },
  {
    "function_name": "trigger_cleanup_reservations",
    "parameters": "",
    "function_body": "CREATE OR REPLACE FUNCTION public.trigger_cleanup_reservations()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n    -- Cleanup expired reservations on insert (during new reservations)\r\n    DELETE FROM inventory_reservations\r\n    WHERE expires_at < NOW() - INTERVAL '1 hour'; -- Keep some buffer\r\n    \r\n    RETURN NEW;\r\nEND;\r\n$function$\n"
  },
  {
    "function_name": "update_admin_order_comprehensive",
    "parameters": "p_order_id integer, p_order_data jsonb, p_order_items jsonb",
    "function_body": "CREATE OR REPLACE FUNCTION public.update_admin_order_comprehensive(p_order_id integer, p_order_data jsonb, p_order_items jsonb)\n RETURNS boolean\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    v_order_exists BOOLEAN := FALSE;\r\nBEGIN\r\n    -- Check if order exists\r\n    SELECT EXISTS(SELECT 1 FROM orders WHERE order_id = p_order_id) INTO v_order_exists;\r\n    \r\n    IF NOT v_order_exists THEN\r\n        RAISE EXCEPTION 'Order with ID % does not exist', p_order_id;\r\n    END IF;\r\n    \r\n    -- Update the order\r\n    UPDATE orders SET\r\n        order_date = COALESCE((p_order_data->>'order_date')::DATE, order_date), -- DATE type, not TIMESTAMP\r\n        sub_total = COALESCE((p_order_data->>'sub_total')::NUMERIC, sub_total),\r\n        buying_price = COALESCE((p_order_data->>'buying_price')::NUMERIC, buying_price),\r\n        status = COALESCE(p_order_data->>'status', status),\r\n        saletype = COALESCE(p_order_data->>'saletype', saletype),\r\n        address_id = COALESCE((p_order_data->>'address_id')::INTEGER, address_id),\r\n        customer_id = COALESCE((p_order_data->>'customer_id')::INTEGER, customer_id),\r\n        paid_amount = COALESCE((p_order_data->>'paid_amount')::NUMERIC, paid_amount),\r\n        discount = COALESCE((p_order_data->>'discount')::NUMERIC, discount),\r\n        tax = COALESCE((p_order_data->>'tax')::NUMERIC, tax),\r\n        shipping_fee = COALESCE((p_order_data->>'shipping_fee')::NUMERIC, shipping_fee),\r\n        salesman_comission = COALESCE((p_order_data->>'salesman_comission')::INTEGER, salesman_comission), -- INTEGER type\r\n        payment_method = COALESCE(p_order_data->>'payment_method', payment_method),\r\n        salesman_id = COALESCE((p_order_data->>'salesman_id')::INTEGER, salesman_id)\r\n    WHERE order_id = p_order_id;\r\n    \r\n    -- Delete existing order items\r\n    DELETE FROM order_items WHERE order_id = p_order_id;\r\n    \r\n    -- Insert new order items\r\n    INSERT INTO order_items (\r\n        order_id,\r\n        product_id,\r\n        quantity,\r\n        price,\r\n        unit,\r\n        total_buy_price,\r\n        variant_id\r\n    )\r\n    SELECT \r\n        p_order_id,\r\n        (item->>'product_id')::INTEGER,\r\n        (item->>'quantity')::INTEGER,\r\n        (item->>'price')::NUMERIC,\r\n        item->>'unit',\r\n        (item->>'total_buy_price')::NUMERIC,\r\n        (item->>'variant_id')::INTEGER -- Required since every product must have variants\r\n    FROM jsonb_array_elements(p_order_items) item;\r\n    \r\n    RETURN TRUE;\r\nEXCEPTION\r\n    WHEN OTHERS THEN\r\n        RAISE;\r\nEND;\r\n$function$\n"
  },
  {
    "function_name": "update_brand_product_count",
    "parameters": "",
    "function_body": "CREATE OR REPLACE FUNCTION public.update_brand_product_count()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$BEGIN\r\n  -- Handle INSERT operation\r\n  IF TG_OP = 'INSERT' THEN\r\n    UPDATE brands\r\n    SET product_count = product_count + 1\r\n    WHERE \"brandID\" = NEW.\"brandID\";\r\n  END IF;\r\n\r\n  -- Handle DELETE operation\r\n  IF TG_OP = 'DELETE' THEN\r\n    UPDATE brands\r\n    SET product_count = product_count - 1\r\n    WHERE \"brandID\" = OLD.\"brandID\";\r\n  END IF;\r\n\r\n  RETURN NULL;\r\nEND;$function$\n"
  },
  {
    "function_name": "update_inventory_after_order",
    "parameters": "",
    "function_body": "CREATE OR REPLACE FUNCTION public.update_inventory_after_order()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n  UPDATE product_variants\n  SET stock_quantity = stock_quantity - NEW.quantity\n  WHERE variant_id = NEW.variant_id;\n  RETURN NEW;\nEND;\n$function$\n"
  },
  {
    "function_name": "update_variant_stock_with_validation",
    "parameters": "p_variant_id_input integer, p_new_stock_value_input integer, p_customer_id_input integer",
    "function_body": "CREATE OR REPLACE FUNCTION public.update_variant_stock_with_validation(p_variant_id_input integer, p_new_stock_value_input integer, p_customer_id_input integer)\n RETURNS boolean\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    v_current_stock_in_db INT;\r\n    v_current_cart_items_total INT;\r\n    v_customer_cart_quantity INT;\r\n    v_debug_message TEXT;\r\nBEGIN\r\n    -- Initialize debug message\r\n    v_debug_message := 'Starting validation for variant: ' || p_variant_id_input || \r\n                      ', new stock: ' || p_new_stock_value_input || \r\n                      ', customer: ' || p_customer_id_input;\r\n    RAISE NOTICE '%', v_debug_message;\r\n\r\n    -- 1. Lock and get current stock\r\n    BEGIN\r\n        SELECT stock INTO v_current_stock_in_db\r\n        FROM public.product_variants\r\n        WHERE variant_id = p_variant_id_input\r\n        FOR UPDATE;\r\n        \r\n        IF NOT FOUND THEN\r\n            v_debug_message := 'Variant not found in database';\r\n            RAISE NOTICE '%', v_debug_message;\r\n            RETURN FALSE;\r\n        END IF;\r\n        \r\n        RAISE NOTICE 'Current stock: %', v_current_stock_in_db;\r\n    EXCEPTION WHEN OTHERS THEN\r\n        v_debug_message := 'Failed to read stock: ' || SQLERRM;\r\n        RAISE NOTICE '%', v_debug_message;\r\n        RETURN FALSE;\r\n    END;\r\n\r\n    -- 2. Get cart quantities\r\n    BEGIN\r\n        -- Global cart quantity\r\n        SELECT COALESCE(SUM(NULLIF(quantity, '')::INT), 0)\r\n        INTO v_current_cart_items_total\r\n        FROM public.cart\r\n        WHERE variant_id = p_variant_id_input;\r\n        \r\n        RAISE NOTICE 'Total in all carts: %', v_current_cart_items_total;\r\n\r\n        -- Customer-specific quantity\r\n        SELECT COALESCE(SUM(NULLIF(quantity, '')::INT), 0)\r\n        INTO v_customer_cart_quantity\r\n        FROM public.cart\r\n        WHERE variant_id = p_variant_id_input\r\n        AND customer_id = p_customer_id_input;\r\n        \r\n        RAISE NOTICE 'In customer cart: %', v_customer_cart_quantity;\r\n    EXCEPTION WHEN OTHERS THEN\r\n        v_debug_message := 'Failed to read cart quantities: ' || SQLERRM;\r\n        RAISE NOTICE '%', v_debug_message;\r\n        RETURN FALSE;\r\n    END;\r\n\r\n    -- 3. Validate stock\r\n    IF (p_new_stock_value_input + v_current_cart_items_total) <= v_current_stock_in_db AND\r\n       (p_new_stock_value_input + v_customer_cart_quantity) <= v_current_stock_in_db THEN\r\n        \r\n        -- Update stock\r\n        UPDATE public.product_variants\r\n        SET stock = p_new_stock_value_input,\r\n            updated_at = NOW()\r\n        WHERE variant_id = p_variant_id_input;\r\n        \r\n        v_debug_message := 'SUCCESS: Stock updated to ' || p_new_stock_value_input || \r\n                          ' (Was: ' || v_current_stock_in_db || \r\n                          ', All carts: ' || v_current_cart_items_total || \r\n                          ', Customer cart: ' || v_customer_cart_quantity || ')';\r\n        RAISE NOTICE '%', v_debug_message;\r\n        RETURN TRUE;\r\n    ELSE\r\n        v_debug_message := 'FAILED: Cannot update stock. Requested: ' || p_new_stock_value_input || \r\n                          ' + Existing carts: ' || v_current_cart_items_total || \r\n                          ' + Customer cart: ' || v_customer_cart_quantity || \r\n                          ' > Current stock: ' || v_current_stock_in_db;\r\n        RAISE NOTICE '%', v_debug_message;\r\n        RETURN FALSE;\r\n    END IF;\r\nEXCEPTION\r\n    WHEN OTHERS THEN\r\n        v_debug_message := 'UNEXPECTED ERROR: ' || SQLERRM;\r\n        RAISE NOTICE '%', v_debug_message;\r\n        RETURN FALSE;\r\nEND;\r\n$function$\n"
  },
  {
    "function_name": "urlencode",
    "parameters": "string bytea",
    "function_body": "CREATE OR REPLACE FUNCTION public.urlencode(string bytea)\n RETURNS text\n LANGUAGE c\n IMMUTABLE STRICT\nAS '$libdir/http', $function$urlencode$function$\n"
  },
  {
    "function_name": "urlencode",
    "parameters": "string character varying",
    "function_body": "CREATE OR REPLACE FUNCTION public.urlencode(string character varying)\n RETURNS text\n LANGUAGE c\n IMMUTABLE STRICT\nAS '$libdir/http', $function$urlencode$function$\n"
  },
  {
    "function_name": "urlencode",
    "parameters": "data jsonb",
    "function_body": "CREATE OR REPLACE FUNCTION public.urlencode(data jsonb)\n RETURNS text\n LANGUAGE c\n IMMUTABLE STRICT\nAS '$libdir/http', $function$urlencode_jsonb$function$\n"
  },
  {
    "function_name": "validate_admin_cart_stock",
    "parameters": "p_cart_items jsonb",
    "function_body": "CREATE OR REPLACE FUNCTION public.validate_admin_cart_stock(p_cart_items jsonb)\n RETURNS TABLE(is_valid boolean, error_message text, variant_id integer)\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    item JSONB;\r\n    v_variant_stock INTEGER;\r\n    v_quantity INTEGER;\r\nBEGIN\r\n    -- Loop through each cart item (all products must have variants)\r\n    FOR item IN SELECT * FROM jsonb_array_elements(p_cart_items)\r\n    LOOP\r\n        v_quantity := (item->>'quantity')::INTEGER;\r\n        \r\n        -- Check variant stock (every product must have at least one variant)\r\n        SELECT stock INTO v_variant_stock \r\n        FROM product_variants \r\n        WHERE variant_id = (item->>'variantId')::INTEGER \r\n        AND is_visible = true;\r\n        \r\n        IF v_variant_stock IS NULL THEN\r\n            RETURN QUERY SELECT false, 'Product variant not found or not visible', \r\n                (item->>'variantId')::INTEGER;\r\n            RETURN;\r\n        END IF;\r\n        \r\n        IF v_variant_stock < v_quantity THEN\r\n            RETURN QUERY SELECT false, \r\n                format('Insufficient stock for variant. Available: %s, Requested: %s', \r\n                       v_variant_stock, v_quantity),\r\n                (item->>'variantId')::INTEGER;\r\n            RETURN;\r\n        END IF;\r\n    END LOOP;\r\n    \r\n    -- If we get here, all validations passed\r\n    RETURN QUERY SELECT true, 'Stock validation passed'::TEXT, NULL::INTEGER;\r\nEND;\r\n$function$\n"
  },
  {
    "function_name": "validate_order_integrity",
    "parameters": "order_id_param integer",
    "function_body": "CREATE OR REPLACE FUNCTION public.validate_order_integrity(order_id_param integer)\n RETURNS boolean\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    order_total DECIMAL;\r\n    calculated_total DECIMAL;\r\n    item_count INTEGER;\r\nBEGIN\r\n    -- Get order total from orders table\r\n    SELECT paid_amount INTO order_total\r\n    FROM orders\r\n    WHERE order_id = order_id_param;\r\n    \r\n    -- Calculate total from order items\r\n    SELECT COUNT(*), COALESCE(SUM(price * quantity), 0)\r\n    INTO item_count, calculated_total\r\n    FROM order_items\r\n    WHERE order_id = order_id_param;\r\n    \r\n    -- Validate totals match (allow small rounding differences)\r\n    IF ABS(order_total - calculated_total) > 0.01 THEN\r\n        INSERT INTO security_audit_log (event_type, event_data, severity)\r\n        VALUES ('order_integrity_violation',\r\n                jsonb_build_object(\r\n                    'order_id', order_id_param,\r\n                    'order_total', order_total,\r\n                    'calculated_total', calculated_total,\r\n                    'difference', order_total - calculated_total\r\n                ),\r\n                'critical');\r\n        RETURN FALSE;\r\n    END IF;\r\n    \r\n    -- Validate order has items\r\n    IF item_count = 0 THEN\r\n        INSERT INTO security_audit_log (event_type, event_data, severity)\r\n        VALUES ('empty_order_detected',\r\n                jsonb_build_object('order_id', order_id_param),\r\n                'error');\r\n        RETURN FALSE;\r\n    END IF;\r\n    \r\n    RETURN TRUE;\r\nEND;\r\n$function$\n"
  }
]